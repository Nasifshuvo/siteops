import { type Request, type Response } from 'express';
import path from 'path';
import fs from 'fs';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

// Sites root: configurable via SITES_PATH env variable
const getSitesRoot = () => process.env.SITES_PATH || path.join(process.cwd(), 'sites');

// Let's Encrypt certificate paths
const LETSENCRYPT_LIVE = '/etc/letsencrypt/live';
const NGINX_SITES_AVAILABLE = '/etc/nginx/sites-available';
const NGINX_SITES_ENABLED = '/etc/nginx/sites-enabled';

/**
 * Parse certificate expiry date using openssl
 */
async function getCertificateInfo(domain: string): Promise<{
    validFrom: string;
    validTo: string;
    issuer: string;
    daysRemaining: number;
} | null> {
    const certPath = path.join(LETSENCRYPT_LIVE, domain, 'cert.pem');
    
    if (!fs.existsSync(certPath)) {
        return null;
    }

    try {
        // Get certificate dates
        const { stdout: dates } = await execAsync(
            `openssl x509 -in ${certPath} -noout -dates`
        );
        
        // Get issuer
        const { stdout: issuerOut } = await execAsync(
            `openssl x509 -in ${certPath} -noout -issuer`
        );

        const notBeforeMatch = dates.match(/notBefore=(.+)/);
        const notAfterMatch = dates.match(/notAfter=(.+)/);
        const issuerMatch = issuerOut.match(/O\s*=\s*([^,\n]+)/);

        if (!notBeforeMatch || !notAfterMatch || !notBeforeMatch[1] || !notAfterMatch[1]) {
            return null;
        }

        const validFrom = new Date(notBeforeMatch[1]).toISOString();
        const validTo = new Date(notAfterMatch[1]).toISOString();
        const issuer = issuerMatch && issuerMatch[1] ? issuerMatch[1].trim() : 'Unknown';
        
        const now = new Date();
        const expiry = new Date(notAfterMatch[1]);
        const daysRemaining = Math.floor((expiry.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

        return { validFrom, validTo, issuer, daysRemaining };
    } catch (error) {
        console.error('[SSL] Error reading certificate:', error);
        return null;
    }
}

/**
 * Generate nginx HTTPS config for a domain
 */
function generateNginxSSLConfig(domain: string): string {
    return `# SSL Configuration for ${domain}
# Auto-generated by Headless Core

server {
    listen 80;
    listen [::]:80;
    server_name ${domain};
    
    # Redirect HTTP to HTTPS
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${domain};

    # SSL Certificate
    ssl_certificate /etc/letsencrypt/live/${domain}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${domain}/privkey.pem;
    
    # SSL Settings
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers off;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_stapling on;
    ssl_stapling_verify on;

    # Security Headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Proxy to Headless Core
    location / {
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        proxy_cache_bypass $http_upgrade;
    }
}
`;
}

/**
 * Get SSL status for a domain
 * GET /site/ssl/:domain
 */
export const getSSLStatus = async (req: Request, res: Response) => {
    try {
        const domain = req.params.domain as string;
        const sitesRoot = getSitesRoot();
        const sitePath = path.join(sitesRoot, domain);

        // Check if site exists
        if (!fs.existsSync(sitePath)) {
            res.status(404).json({ error: 'Site not found' });
            return;
        }

        // Check if certificate exists
        const certPath = path.join(LETSENCRYPT_LIVE, domain);
        const certExists = fs.existsSync(certPath);

        if (!certExists) {
            res.json({
                domain,
                ssl: {
                    enabled: false,
                    provider: null,
                    status: 'not_configured'
                }
            });
            return;
        }

        // Get certificate info
        const certInfo = await getCertificateInfo(domain);

        if (!certInfo) {
            res.json({
                domain,
                ssl: {
                    enabled: false,
                    provider: 'letsencrypt',
                    status: 'error',
                    message: 'Could not read certificate'
                }
            });
            return;
        }

        res.json({
            domain,
            ssl: {
                enabled: true,
                provider: 'letsencrypt',
                issuer: certInfo.issuer,
                validFrom: certInfo.validFrom,
                validTo: certInfo.validTo,
                daysRemaining: certInfo.daysRemaining,
                autoRenew: true,
                status: certInfo.daysRemaining > 0 ? 'active' : 'expired'
            }
        });
    } catch (error) {
        console.error('[SSL] Error getting status:', error);
        res.status(500).json({ error: 'Failed to get SSL status' });
    }
};

/**
 * Generate Let's Encrypt certificate
 * POST /site/ssl/generate
 * Body: { domain: string, email?: string }
 */
export const generateSSL = async (req: Request, res: Response) => {
    try {
        const { domain, email } = req.body;

        // Validation
        if (!domain || typeof domain !== 'string') {
            res.status(400).json({ error: 'Domain is required' });
            return;
        }

        const sitesRoot = getSitesRoot();
        const sitePath = path.join(sitesRoot, domain);

        // Check if site exists
        if (!fs.existsSync(sitePath)) {
            res.status(404).json({ error: 'Site not found. Create the site first.' });
            return;
        }

        // Check if certificate already exists
        const certPath = path.join(LETSENCRYPT_LIVE, domain);
        if (fs.existsSync(certPath)) {
            res.status(409).json({ 
                error: 'Certificate already exists',
                message: 'Use /site/ssl/renew/:domain to renew'
            });
            return;
        }

        console.log(`[SSL] Generating certificate for ${domain}...`);

        // Generate certificate using certbot
        const emailArg = email ? `--email ${email}` : '--register-unsafely-without-email';
        const certbotCmd = `certbot certonly --nginx -d ${domain} ${emailArg} --agree-tos --non-interactive`;

        try {
            const { stdout, stderr } = await execAsync(certbotCmd);
            console.log('[SSL] Certbot output:', stdout);
            if (stderr) console.log('[SSL] Certbot stderr:', stderr);
        } catch (certError: unknown) {
            const error = certError as { stderr?: string; message?: string };
            console.error('[SSL] Certbot error:', error);
            res.status(500).json({ 
                error: 'Failed to generate certificate',
                details: error.stderr || error.message
            });
            return;
        }

        // Generate nginx SSL config
        const nginxConfig = generateNginxSSLConfig(domain);
        const nginxConfigPath = path.join(NGINX_SITES_AVAILABLE, `ssl-${domain}`);
        
        fs.writeFileSync(nginxConfigPath, nginxConfig, 'utf-8');
        console.log(`[SSL] Created nginx config: ${nginxConfigPath}`);

        // Enable the site (create symlink)
        const enabledPath = path.join(NGINX_SITES_ENABLED, `ssl-${domain}`);
        if (!fs.existsSync(enabledPath)) {
            fs.symlinkSync(nginxConfigPath, enabledPath);
            console.log(`[SSL] Enabled site: ${enabledPath}`);
        }

        // Reload nginx
        try {
            await execAsync('nginx -t');
            await execAsync('systemctl reload nginx');
            console.log('[SSL] Nginx reloaded successfully');
        } catch (nginxError: unknown) {
            const error = nginxError as { message?: string };
            console.error('[SSL] Nginx reload error:', error);
            res.status(500).json({ 
                error: 'Certificate generated but nginx reload failed',
                details: error.message
            });
            return;
        }

        // Get certificate info
        const certInfo = await getCertificateInfo(domain);

        res.status(201).json({
            message: 'SSL certificate generated successfully',
            domain,
            ssl: {
                enabled: true,
                provider: 'letsencrypt',
                issuer: certInfo?.issuer || "Let's Encrypt",
                validFrom: certInfo?.validFrom,
                validTo: certInfo?.validTo,
                daysRemaining: certInfo?.daysRemaining,
                autoRenew: true,
                status: 'active'
            }
        });
    } catch (error) {
        console.error('[SSL] Error generating certificate:', error);
        res.status(500).json({ error: 'Failed to generate SSL certificate' });
    }
};

/**
 * Renew SSL certificate
 * POST /site/ssl/renew/:domain
 */
export const renewSSL = async (req: Request, res: Response) => {
    try {
        const domain = req.params.domain as string;

        // Check if certificate exists
        const certPath = path.join(LETSENCRYPT_LIVE, domain);
        if (!fs.existsSync(certPath)) {
            res.status(404).json({ error: 'No certificate found for this domain' });
            return;
        }

        console.log(`[SSL] Renewing certificate for ${domain}...`);

        // Renew certificate
        try {
            const { stdout, stderr } = await execAsync(`certbot renew --cert-name ${domain} --force-renewal`);
            console.log('[SSL] Certbot renew output:', stdout);
            if (stderr) console.log('[SSL] Certbot stderr:', stderr);
        } catch (certError: unknown) {
            const error = certError as { stderr?: string; message?: string };
            console.error('[SSL] Certbot renew error:', error);
            res.status(500).json({ 
                error: 'Failed to renew certificate',
                details: error.stderr || error.message
            });
            return;
        }

        // Reload nginx
        await execAsync('systemctl reload nginx');
        console.log('[SSL] Nginx reloaded');

        // Get updated certificate info
        const certInfo = await getCertificateInfo(domain);

        res.json({
            message: 'SSL certificate renewed successfully',
            domain,
            ssl: {
                enabled: true,
                provider: 'letsencrypt',
                issuer: certInfo?.issuer,
                validFrom: certInfo?.validFrom,
                validTo: certInfo?.validTo,
                daysRemaining: certInfo?.daysRemaining,
                autoRenew: true,
                status: 'active'
            }
        });
    } catch (error) {
        console.error('[SSL] Error renewing certificate:', error);
        res.status(500).json({ error: 'Failed to renew SSL certificate' });
    }
};

/**
 * Remove SSL certificate
 * DELETE /site/ssl/:domain
 */
export const removeSSL = async (req: Request, res: Response) => {
    try {
        const domain = req.params.domain as string;

        // Check if certificate exists
        const certPath = path.join(LETSENCRYPT_LIVE, domain);
        if (!fs.existsSync(certPath)) {
            res.status(404).json({ error: 'No certificate found for this domain' });
            return;
        }

        console.log(`[SSL] Removing certificate for ${domain}...`);

        // Remove nginx SSL config
        const enabledPath = path.join(NGINX_SITES_ENABLED, `ssl-${domain}`);
        const availablePath = path.join(NGINX_SITES_AVAILABLE, `ssl-${domain}`);

        if (fs.existsSync(enabledPath)) {
            fs.unlinkSync(enabledPath);
            console.log(`[SSL] Removed enabled site: ${enabledPath}`);
        }

        if (fs.existsSync(availablePath)) {
            fs.unlinkSync(availablePath);
            console.log(`[SSL] Removed available site: ${availablePath}`);
        }

        // Delete certificate using certbot
        try {
            await execAsync(`certbot delete --cert-name ${domain} --non-interactive`);
            console.log('[SSL] Certificate deleted');
        } catch (certError: unknown) {
            const error = certError as { message?: string };
            console.error('[SSL] Certbot delete error:', error);
            // Continue anyway - nginx config already removed
        }

        // Reload nginx
        await execAsync('systemctl reload nginx');
        console.log('[SSL] Nginx reloaded');

        res.json({
            message: 'SSL certificate removed successfully',
            domain,
            ssl: {
                enabled: false,
                status: 'removed'
            }
        });
    } catch (error) {
        console.error('[SSL] Error removing certificate:', error);
        res.status(500).json({ error: 'Failed to remove SSL certificate' });
    }
};

/**
 * List all SSL certificates
 * GET /site/ssl/list
 */
export const listSSLCertificates = async (req: Request, res: Response) => {
    try {
        const certificates: Array<{
            domain: string;
            validTo: string;
            daysRemaining: number;
            status: string;
        }> = [];

        // Check if letsencrypt directory exists
        if (!fs.existsSync(LETSENCRYPT_LIVE)) {
            res.json({ certificates: [] });
            return;
        }

        // Read all certificate directories
        const domains = fs.readdirSync(LETSENCRYPT_LIVE).filter(name => {
            const fullPath = path.join(LETSENCRYPT_LIVE, name);
            return fs.lstatSync(fullPath).isDirectory() && name !== 'README';
        });

        for (const domain of domains) {
            const certInfo = await getCertificateInfo(domain);
            if (certInfo) {
                certificates.push({
                    domain,
                    validTo: certInfo.validTo,
                    daysRemaining: certInfo.daysRemaining,
                    status: certInfo.daysRemaining > 0 ? 'active' : 'expired'
                });
            }
        }

        // Sort by days remaining (ascending)
        certificates.sort((a, b) => a.daysRemaining - b.daysRemaining);

        res.json({ certificates });
    } catch (error) {
        console.error('[SSL] Error listing certificates:', error);
        res.status(500).json({ error: 'Failed to list SSL certificates' });
    }
};
